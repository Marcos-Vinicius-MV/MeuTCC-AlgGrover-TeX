\section{M\'{e}todos de Supress\~{a}o e Mitigaç\~{a}o}
\label{sec:supressaoMitigacao}

Como discutido por Preskill \citeyear{Preskill2018_NISQ}, o mundo experimenta no cen\'{a}rio atual a era da tecnologia Qu\^{a}ntica de Escala Intermedi\'{a}ria Ruidosa (\simboloinline{NISQ}{\textit{Noisy Intermediate-Scale Quantum}}, na sigla em ingl\^{e}s para \textit{Noisy Intermediate-Scale Quantum}), que descreve o “tamanho” dos CQs dispon\'{i}veis atualmente em termos de quantidade de qubits (entre $50$ e algumas centenas), enquanto o termo “ruidoso” faz jus ao objeto de estudo desta produç\~{a}o: ru\'{i}do qu\^{a}ntico, que, ainda segundo ele, adv\'{e}m da incapacidade de se controlar fielmente as interaç\~{o}es dos qubits. 

\begin{quote}
    “[...] com esses dispositivos barulhentos n\~{a}o esperamos ser capazes de executar um circuito que contenha muito mais do que cerca de 1000 portas — isto \'{e}, 1000 operaç\~{o}es fundamentais de dois qubits — porque o ru\'{i}do sobrecarregar\'{a} o sinal em um circuito muito maior do que isso. Essa limitaç\~{a}o no tamanho do circuito imp\~{o}e um teto ao poder computacional da tecnologia NISQ. Eventualmente, faremos melhor, usando correç\~{a}o de erro qu\^{a}ntico para escalar para circuitos maiores.” \cite{Preskill2018_NISQ}.
\end{quote}

Dado o exposto, torna-se imprescind\'{i}vel a utilizaç\~{a}o de pelo menos alguns dos m\'{e}todos que ser\~{a}o aqui introduzidos, cabendo ao usu\'{a}rio optar por aqueles que mais se adequam às caracter\'{i}sticas intr\'{i}nsecas a cada circuito, espec\'{i}ficas de cada aplicaç\~{a}o. \'{e} esperado que este comp\^{e}ndio seja \'{u}til para servir de fonte de pesquisa para auxiliar nessa tomada de decis\~{a}o.

\subsection{Supress\~{a}o}
\label{subSec:supressao}


As t\'{e}cnicas de supress\~{a}o de ru\'{i}do em computaç\~{a}o qu\^{a}ntica visam reduzir o surgimento do ru\'{i}do durante o processamento ou execuç\~{a}o do circuito (como decoer\^{e}ncia e erros de porta), e, por conseguinte, evitar os efeitos indesejados sem recorrer, necessariamente, a códigos completos de correç\~{a}o de erros. Essas t\'{e}cnicas s\~{a}o especialmente relevantes no contexto dos dispositivos NISQ, onde a presença de ru\'{i}do ainda \'{e} significativa. As t\'{e}cnicas de supress\~{a}o contempladas pelo \emph{Qiskit} e que aqui tamb\'{e}m o ser\~{a}o, s\~{a}o:

\subsubsection*{Otimizaç\~{a}o do Circuito Qu\^{a}ntico}
\label{subSubSec:otimizacao}

A otimizaç\~{a}o ocorre na fase de compilaç\~{a}o, e \'{e} um m\'{e}todo que deve ser utilizado durante o processo de mapeamento do circuito qu\^{a}ntico virtual\footnote{Um circuito qu\^{a}ntico virtual refere-se à representaç\~{a}o abstrata e idealizada de um circuito qu\^{a}ntico, em que n\~{a}o h\'{a} interfer\^{e}ncia de ru\'{i}dos qu\^{a}nticos ou limitaç\~{o}es tecnológicas da implementaç\~{a}o f\'{i}sica.} para o circuito qu\^{a}ntico f\'{i}sico\footnote{
Um circuito qu\^{a}ntico f\'{i}sico \'{e} aquele implementado em hardware real, tamb\'{e}m chamado \textit{backend}, utilizando as portas lógicas que o mesmo suporta.
} utilizando para isso a funç\~{a}o “transpile”, que possui quatro poss\'{i}veis n\'{i}veis: n\'{i}vel $0$, que n\~{a}o h\'{a} otimizaç\~{a}o; n\'{i}vel $1$, que combina decomposiç\~{a}o otimizada de portas de um qubit com cancelamento de portas inversas consecutivas; n\'{i}vel $2$, que utiliza um m\'{e}todo de cancelamento comutativo em vez de cancelamento de $C_X$'s, resultando na diminuiç\~{a}o de portas redundantes; n\'{i}vel $3$, que \'{e} o n\'{i}vel de otimizaç\~{a}o mais eficaz, embora mais exigente em se tratando de poder computacional, pois emprega v\'{a}rios m\'{e}todos, inclusive decomposiç\~{a}o otimizada de portas de um qubit, usada no n\'{i}vel um, e cancelamento comutativo aplicado no n\'{i}vel dois, al\'{e}m de outros m\'{e}todos como coleç\~{a}o de subcircuitos de dois qubits, consolidaç\~{a}o de portas lógicas (blocos) consecutivas atuantes em um mesmo qubit para um \'{u}nico bloco mais otimizado, e, por fim, utiliza s\'{i}ntese unit\'{a}ria, que pode fazer uma simplificaç\~{a}o das portas por suas portas-base \cite{IBM2025_transpile}.

\textbf{Decomposiç\~{a}o Otimizada de Portas de um Qubit} \cite{IBM2025_OptimGates1qb}: Esse m\'{e}todo visa otimizar cadeias de portas de qubit \'{u}nico combinando-as em uma \'{u}nica porta. As condiç\~{o}es empregadas pelo algoritmo para tomar a decis\~{a}o de substituir o conjunto original de portas por uma nova configuraç\~{a}o s\~{a}o:
se a corrente original estava fora da base: substituir;
se a cadeia original estava na base, mas a ress\'{i}ntese \'{e} menor erro: substituir;
se a cadeia original cont\'{e}m uma porta de pulso: n\~{a}o substitua;
se a cadeia original equivale à identidade: substituir por nulo;
O erro \'{e} calculado como uma multiplicaç\~{a}o dos erros de portas individuais naquele qubit.

\textbf{Cancelamento Inverso} \cite{IBM2025_CancelInverso}: O objetivo desse m\'{e}todo \'{e} identificar e remover pares de portas qu\^{a}nticas consecutivas que s\~{a}o inversas uma da outra, otimizando assim o circuito ao eliminar operaç\~{o}es redundantes. Ao aplic\'{a}-lo, \'{e} poss\'{i}vel reduzir a profundidade do circuito e minimizar poss\'{i}veis fontes de erro, contribuindo para a execuç\~{a}o mais eficiente de algoritmos qu\^{a}nticos.

\textbf{Cancelamento Comutativo }\cite{IBM2025_CancelComutativo}: O objetivo desse m\'{e}todo \'{e} identificar e remover portas auto-inversas redundantes, aproveitando as relaç\~{o}es de comutaç\~{a}o no circuito. As portas consideradas incluem: $H$, $X$, $Y$, $Z$, $C_X$, $C_Y$, $C_Z$. Ao aplic\'{a}-lo, \'{e} poss\'{i}vel reduzir a complexidade do circuito, eliminando operaç\~{o}es redundantes e melhorando a efici\^{e}ncia da execuç\~{a}o em dispositivos qu\^{a}nticos.

\textbf{Coleç\~{a}o de Subcircuitos de 2 Qubits} \cite{IBM2025_ColetaBlock2qb}: \'{e} uma ferramenta de an\'{a}lise que identifica e agrupa subcircuitos compostos por portas de dois qubits que s\~{a}o adjacentes (vizinhas) e atuam nos mesmos qubits. Esses blocos coletados podem ser posteriormente otimizados ou sintetizados de maneira mais eficiente por outras passagens do \textit{transpile}. Ao utiliz\'{a}-la, \'{e} poss\'{i}vel preparar o circuito para otimizaç\~{o}es subsequentes, como a consolidaç\~{a}o de operaç\~{o}es ou a reduç\~{a}o da profundidade do circuito, melhorando a efici\^{e}ncia da execuç\~{a}o em dispositivos qu\^{a}nticos.

\textbf{Consolidaç\~{a}o de Blocos de Portas Consecutivas} \cite{IBM2025_ConsolidaBlocos}: Essa \'{e} uma transformaç\~{a}o que substitui sequ\^{e}ncias de portas consecutivas atuando nos mesmos qubits por um \'{u}nico nó unit\'{a}rio. Geralmente, esses blocos s\~{a}o selecionados anteriormente por outra ferramenta, como a Coleç\~{a}o de Subcircuitos de 2 Qubits. Essa consolidaç\~{a}o permite que o subcircuito seja ressincronizado posteriormente, potencialmente resultando em uma implementaç\~{a}o mais otimizada. Al\'{e}m disso, \'{e} poss\'{i}vel reduzir a complexidade do circuito, agrupando operaç\~{o}es em unidades \'{u}nicas que podem ser mais eficientes para execuç\~{a}o em hardware qu\^{a}ntico.

\textbf{S\'{i}ntese Unit\'{a}ria} \cite{IBM2025_SinteseUnit}: O objetivo dessa funç\~{a}o \'{e} sintetizar operaç\~{o}es unit\'{a}rias, substituindo sequ\^{e}ncias de portas por implementaç\~{o}es equivalentes que sejam mais eficientes ou que atendam a restriç\~{o}es espec\'{i}ficas do hardware. Funciona atrav\'{e}s da an\'{a}lise do circuito em busca de subcircuitos unit\'{a}rios e os reescreve utilizando um conjunto espec\'{i}fico de portas base, visando otimizar o circuito de acordo com as caracter\'{i}sticas do \textit{backend} (CQ) alvo.

\subsubsection*{Desacoplamento Din\^{a}mico (DD)}
\label{subSubSec:DD}

“Circuitos qu\^{a}nticos s\~{a}o executados em \emph{hardware} IBM como sequ\^{e}ncias de pulsos de micro-ondas que precisam ser agendados e executados em intervalos de tempo precisos.” \cite{IBM_DD}. Durante uma operaç\~{a}o qualquer, alguns \emph{qubits} podem passar alguns intervalos de tempo sem que estejam sendo utilizados, devido à exist\^{e}ncia de lacunas nos circuitos; esses \emph{qubits} podem acabar interagindo entre si de forma n\~{a}o controlada e indevida. Essas interaç\~{o}es s\~{a}o respons\'{a}veis por gerar quantidades significativas de erros no resultado final. O \textit{Dynamical Decoupling} (DD) \'{e} muito \'{u}til para este tipo de circuitos, onde h\'{a} lacunas, pois “\'{e} uma t\'{e}cnica de controle qu\^{a}ntico que consiste em aplicar sequ\^{e}ncias personalizadas de pulsos ao sistema qu\^{a}ntico considerado para cancelar (ou fazer a m\'{e}dia) da interaç\~{a}o com o ambiente” \cite{lopez2023_DD}, ou seja, s\~{a}o inseridas sequ\^{e}ncias de pulsos de micro-ondas nos \emph{qubits} ociosos que s\~{a}o propositalmente sim\'{e}tricos, para que sua m\'{e}dia total seja cancelada, de modo que se equivalham à operaç\~{a}o de identidade, isto \'{e}, n\~{a}o causem perturbaç\~{o}es no sistema. Esses pulsos controlados agem de modo a suprimir erros de interaç\~{a}o indevida, ao impedir que haja a interaç\~{a}o entre \emph{qubits}. 

\subsubsection*{Compilaç\~{a}o Aleatória (\textit{Pauli Twirling})}
\label{subSubSec:twirling}

O m\'{e}todo de \textit{Pauli twirling} ou \textit{Randomized Compiling} \'{e} uma t\'{e}cnica de supress\~{a}o de erros que transforma canais de ru\'{i}do arbitr\'{a}rios em canais do tipo Pauli, os quais s\~{a}o mais f\'{a}ceis de modelar e corrigir. A ideia central \'{e} aplicar, de forma aleatória, operaç\~{o}es do grupo de Pauli – como os operadores $I$, $X$, $Y$ e $Z$ – antes e depois de um canal de ru\'{i}do. Ao se fazer a m\'{e}dia (ou "\textit{twirling}") sobre essa distribuiç\~{a}o aleatória de operaç\~{o}es, os termos n\~{a}o diagonais (ou seja, os erros coerentes) tendem a se cancelar, resultando em um canal de ru\'{i}do que age de forma puramente estoc\'{a}stica\footnote{Um erro estoc\'{a}stico ocorre de forma aleatória, seguindo uma distribuiç\~{a}o probabil\'{i}stica, ao contr\'{a}rio dos erros coerentes, que se manifestam de maneira sistem\'{a}tica. Esse comportamento possibilita que t\'{e}cnicas de correç\~{a}o e mitigaç\~{a}o sejam aplicadas de forma mais eficaz, pois os efeitos do ru\'{i}do podem ser tratados estatisticamente \cite{Nielsen_Chuang2010_Livro}}.

Em outras palavras, o ru\'{i}do original, que pode apresentar comportamentos complexos e coerentes, \'{e} transformado em um ru\'{i}do que se comporta como uma mistura probabil\'{i}stica de erros simples (por exemplo, erros de \textit{bit-flip} ou \textit{phase-flip}). Essa transformaç\~{a}o facilita tanto a an\'{a}lise teórica quanto a mitigaç\~{a}o pr\'{a}tica dos erros, pois canais de ru\'{i}do do tipo Pauli s\~{a}o bem compreendidos e possuem uma estrutura que pode ser incorporada em protocolos de correç\~{a}o de erros e t\'{e}cnicas de mitigaç\~{a}o, como o \textit{randomized benchmarking}.
\begin{quote}
    
"Realizado sozinho, ele pode mitigar ru\'{i}do coerente porque o ru\'{i}do coerente tende a se acumular quadraticamente com o n\'{u}mero de operaç\~{o}es, enquanto o ru\'{i}do de Pauli se acumula linearmente. O twirling de Pauli \'{e} frequentemente combinado com outras t\'{e}cnicas de mitigaç\~{a}o de erros que funcionam melhor com ru\'{i}do de Pauli do que com ru\'{i}do arbitr\'{a}rio" \cite{IBM_PauliTwirling}.
\end{quote}

Conforme discutido por Emerson \textit{et al.} \citeyear{emerson2005_PauliTwirling}, essa t\'{e}cnica \'{e} fundamental para converter erros que se acumulam de maneira prejudicial em erros estoc\'{a}sticos, cuja influ\^{e}ncia pode ser controlada e, em muitos casos, mitigada atrav\'{e}s de m\'{e}todos de pós-processamento. Trabalhos posteriores, como o de Temme \textit{et al.}  \citeyear{temme2017_PauliTwirling}, demonstram aplicaç\~{o}es pr\'{a}ticas dessa t\'{e}cnica para melhorar a fidelidade de circuitos qu\^{a}nticos de curta profundidade, tornando os resultados experimentais mais próximos do ideal.

\subsection{Mitigaç\~{a}o}
\label{subSec:mitigacao}

T\'{e}cnicas de mitigaç\~{a}o s\~{a}o utilizadas como complemento às de supress\~{a}o, aplicadas no pós-processamento com o intuito de compensar os efeitos dos erros induzidos nos resultados medidos pela aç\~{a}o do ru\'{i}do que n\~{a}o pôde ser totalmente cancelado na supress\~{a}o.

\subsubsection*{Extinç\~{a}o de Erro de Leitura Giratória (TREX)}
\label{subSubSec:trex}

O \textit{Twirled Readout Error eXtinction} (TREX) \'{e} uma t\'{e}cnica de mitigaç\~{a}o de erros, especificamente projetada para reduzir os erros associados à leitura (\textit{readout}) dos \emph{qubits} durante as mediç\~{o}es. Essa abordagem \'{e} baseada no conceito de \textit{twirling} de mediç\~{o}es, que envolve a aplicaç\~{a}o aleatória de operaç\~{o}es de Pauli $X$ antes das mediç\~{o}es, seguida de uma invers\~{a}o correspondente dos bits medidos. O objetivo principal do TREX \'{e} diagonalizar a matriz de transfer\^{e}ncia de erro de leitura, facilitando sua invers\~{a}o e, consequentemente, a correç\~{a}o dos erros de leitura.

O funcionamento dessa t\'{e}cnica consiste na substituiç\~{a}o (de forma aleatória) do processo de mediç\~{a}o, em que uma mediç\~{a}o simples \'{e} trocada por um processo de medida composto de tr\^{e}s etapas: primeiro, os canais s\~{a}o submetidos a Portas $X$, que invertem o estado dos \emph{qubits} (\textit{bit-flip}) nos quais atuaram; segundo, após as aplicaç\~{o}es das Portas $X$, \'{e} realizada uma mediç\~{a}o comum; por fim, \'{e} feito o ajuste dos estados, de modo que os canais em que houve atuaç\~{a}o de Portas $X$ antes da medida t\^{e}m seu estado corrigido (invertido) classicamente.
Essa sequ\^{e}ncia de operaç\~{o}es transforma o canal de erro de leitura original em uma forma diagonal, onde os elementos fora da diagonal principal s\~{a}o minimizados. Essa diagonalizaç\~{a}o simplifica a invers\~{a}o da matriz de erro, permitindo uma mitigaç\~{a}o mais eficaz dos erros de leitura.

O m\'{e}todo TREX apresenta diversas vantagens no contexto da mitigaç\~{a}o de erros em mediç\~{o}es qu\^{a}nticas. Uma de suas principais qualidades \'{e} o fato de n\~{a}o assumir um modelo espec\'{i}fico de ru\'{i}do, o que o torna uma t\'{e}cnica vers\'{a}til e aplic\'{a}vel a uma ampla variedade de sistemas qu\^{a}nticos. Al\'{e}m disso, ao incorporar uma etapa de randomizaç\~{a}o com operaç\~{o}es de Pauli antes da mediç\~{a}o, o TREX contribui para a reduç\~{a}o de erros correlacionados entre \emph{qubits}. Outro ponto favor\'{a}vel \'{e} a simplicidade de sua implementaç\~{a}o: o m\'{e}todo exige apenas a inserç\~{a}o de operaç\~{o}es qu\^{a}nticas simples antes das mediç\~{o}es e a correç\~{a}o cl\'{a}ssica correspondente nos resultados, dispensando o uso de circuitos qu\^{a}nticos adicionais complexos ou ajustes estruturais profundos no experimento.

\subsubsection*{Extrapolaç\~{a}o de Ru\'{i}do Zero (ZNE)}
\label{subSubSec:zne}

O m\'{e}todo de \textit{Zero Noise Extrapolation} (ZNE) \'{e} uma t\'{e}cnica de mitigaç\~{a}o de ru\'{i}do baseada em pós-processamento que tem como objetivo estimar o valor ideal de uma medida qu\^{a}ntica -- ou seja, o valor que seria obtido caso n\~{a}o houvesse ru\'{i}do no sistema. Essa estimativa \'{e} feita a partir da execuç\~{a}o de m\'{u}ltiplas vers\~{o}es do mesmo circuito qu\^{a}ntico, cada uma com diferentes n\'{i}veis de ru\'{i}do artificialmente aumentados. A ideia central \'{e} que, ao entender como o ru\'{i}do afeta os resultados, \'{e} poss\'{i}vel extrapolar os valores obtidos para o caso em que o ru\'{i}do \'{e} zero.

A implementaç\~{a}o do ZNE consiste, em linhas gerais, em tr\^{e}s etapas principais. Primeiramente, realiza-se a amplificaç\~{a}o do ru\'{i}do no circuito original. Essa amplificaç\~{a}o pode ser feita, por exemplo, repetindo certas portas qu\^{a}nticas, como portas $CNOT$, o que efetivamente aumenta o tempo de execuç\~{a}o do circuito e, consequentemente, sua exposiç\~{a}o ao ru\'{i}do. Em seguida, executa-se o circuito v\'{a}rias vezes, cada vez com um fator diferente de amplificaç\~{a}o de ru\'{i}do, e coleta-se os resultados das medidas. Por fim, aplica-se uma t\'{e}cnica matem\'{a}tica de extrapolaç\~{a}o -- como a extrapolaç\~{a}o linear, quadr\'{a}tica ou de Richardson -- para estimar o resultado que o circuito teria fornecido na aus\^{e}ncia de ru\'{i}do.

Entre as vantagens do ZNE, destaca-se o fato de que a t\'{e}cnica n\~{a}o exige modificaç\~{o}es no hardware qu\^{a}ntico, podendo ser aplicada com acesso apenas à execuç\~{a}o de circuitos e ao controle sobre o tempo de operaç\~{a}o ou o n\'{u}mero de repetiç\~{o}es de determinadas portas. Al\'{e}m disso, \'{e} uma abordagem compat\'{i}vel com diversos modelos de ru\'{i}do, o que a torna bastante vers\'{a}til. No entanto, essa t\'{e}cnica tamb\'{e}m apresenta desvantagens. A principal delas \'{e} o aumento no n\'{u}mero total de execuç\~{o}es necess\'{a}rias, o que pode ser um obst\'{a}culo em dispositivos com tempo de acesso limitado. Al\'{e}m disso, o processo de extrapolaç\~{a}o pode ser sens\'{i}vel a flutuaç\~{o}es estat\'{i}sticas nos resultados, especialmente em hardwares inst\'{a}veis ou com ru\'{i}do n\~{a}o escal\'{a}vel. Dito isso, embora muitas vezes a ZNE possa realmente melhorar os resultados, n\~{a}o \'{e} garantido que os resultados gerados sejam sempre condizentes com a realidade. Mesmo assim, trabalhos como o de Giurgica-Tiron et al. \citeyear{GiurgicaTiron2020_ZNE} demonstram a efici\^{e}ncia do m\'{e}todo para estimativas digitais mitigadas de erro em circuitos qu\^{a}nticos ruidosos.

\subsubsection*{Amplificaç\~{a}o de Erro Probabil\'{i}stica (PEA)}
\label{subSubSec:pea}

A t\'{e}cnica conhecida como \textit{Probabilistic Error Amplification} (PEA) \'{e} uma abordagem que visa amplificar de maneira controlada os efeitos dos erros em circuitos qu\^{a}nticos para facilitar sua quantificaç\~{a}o e, posteriormente, a mitigaç\~{a}o desses erros. A ideia central \'{e} executar vers\~{o}es modificadas do circuito original onde as operaç\~{o}es propensas a introduzir erro s\~{a}o replicadas ou escaladas de forma probabil\'{i}stica. Esse procedimento resulta em um cen\'{a}rio no qual os efeitos do ru\'{i}do s\~{a}o enfatizados, permitindo extrair informaç\~{o}es mais precisas sobre a natureza e a magnitude dos erros presentes no sistema.

O m\'{e}todo se fundamenta na premissa de que, ao amplificar o erro, \'{e} poss\'{i}vel utilizar t\'{e}cnicas matem\'{a}ticas de extrapolaç\~{a}o para estimar o valor que seria obtido em um cen\'{a}rio ideal, ou seja, na aus\^{e}ncia de ru\'{i}do. Essa abordagem \'{e} particularmente \'{u}til para dispositivos NISQ, onde o ru\'{i}do \'{e} inevit\'{a}vel e pode comprometer a fidelidade dos resultados dos algoritmos qu\^{a}nticos. Ao amplificar os erros, o PEA torna mais f\'{a}cil identificar e corrigir os erros coerentes, convertendo-os em erros estoc\'{a}sticos, os quais tendem a se comportar de forma mais aleatória e, portanto, podem ser gerenciados de maneira mais eficaz por t\'{e}cnicas de correç\~{a}o ou mitigaç\~{a}o.

O PEA compartilha fundamentos com outras t\'{e}cnicas de mitigaç\~{a}o de erros, como o \textit{Zero Noise Extrapolation} (ZNE) e o \textit{Probabilistic Error Cancellation} (PEC). No entanto, a diferença reside no foco: enquanto o ZNE e o PEC procuram reduzir o impacto dos erros por meio de estrat\'{e}gias de pós-processamento e invers\~{a}o do canal de ru\'{i}do, o PEA intencionalmente amplifica o sinal de erro para que ele se torne mensur\'{a}vel com maior precis\~{a}o e, ent\~{a}o, possa ser compensado. Essa estrat\'{e}gia permite que as variaç\~{o}es induzidas pelo ru\'{i}do sejam mais facilmente analisadas, servindo de base para m\'{e}todos de correç\~{a}o que ajustem os valores esperados dos observ\'{a}veis.

Trabalhos publicados, como o de Temme et al. \citeyear{temme2017_PauliTwirling} e Endo et al. \citeyear{Endo2018_PEA}, discutem de maneira aprofundada como a amplificaç\~{a}o e o cancelamento probabil\'{i}stico dos erros podem melhorar a precis\~{a}o dos resultados em circuitos qu\^{a}nticos ruidosos. De acordo com Temme et al. \citeyear{temme2017_PauliTwirling}, amplificar os erros de forma controlada permite uma melhor estimativa dos efeitos do ru\'{i}do, possibilitando uma correç\~{a}o mais efetiva e elevando a fidelidade dos resultados. J\'{a} Endo et al. \citeyear{Endo2018_PEA} demonstram a aplicabilidade pr\'{a}tica de t\'{e}cnicas de mitigaç\~{a}o em dispositivos qu\^{a}nticos de curto tempo de execuç\~{a}o, ressaltando a import\^{a}ncia de estrat\'{e}gias que convertam erros coerentes em erros estoc\'{a}sticos, os quais s\~{a}o mais f\'{a}ceis de serem gerenciados. No entanto, em seu trabalho, Kim et al. \citeyear{Kim2023_DD_PT_PEA} alertam sobre como alguns “resultados podem desviar arbitrariamente do resultado desejado” quando se tenta aplicar a amplificaç\~{a}o de ru\'{i}dos em modelos que sejam mesmo que ligeiramente mais complexos.

Em resumo, o PEA consiste em amplificar os erros de forma probabil\'{i}stica, para ent\~{a}o utilizar t\'{e}cnicas de extrapolaç\~{a}o que estimem o valor ideal do circuito, ou seja, o valor que se obteria na aus\^{e}ncia de ru\'{i}do. Essa abordagem se mostra promissora para melhorar a precis\~{a}o dos resultados em dispositivos qu\^{a}nticos atuais e \'{e} uma ferramenta complementar importante de mitigaç\~{a}o de ru\'{i}do qu\^{a}ntico.

\subsubsection*{Cancelamento de Erro Probabil\'{i}stico (PEC)}
\label{subSubSec:pec}

O \textit{Probabilistic Error Cancellation} \'{e} uma das t\'{e}cnicas mais potentes de mitigaç\~{a}o de erros em sistemas qu\^{a}nticos NISQ, pois permite obter estimativas n\~{a}o enviesadas dos valores esperados de observ\'{a}veis mesmo na presença de ru\'{i}do significativo. A ideia central do PEC \'{e} representar cada operaç\~{a}o qu\^{a}ntica ideal como uma combinaç\~{a}o linear de operaç\~{o}es ruidosas que o hardware realmente implementa, usando quasi-probabilidades {$\eta_i$} que podem assumir valores negativos ou maiores que $1$ para “inverter” estatisticamente o efeito do ru\'{i}do \cite{Mitiq2025_PEC}.

Na pr\'{a}tica, isso significa primeiro caracterizar o canal de ru\'{i}do do dispositivo por meio de protocolos de tomografia (por exemplo, \textit{Pauli‑Lindblad tomography}), de modo a aprender o comportamento exato de $U_{ruidoso, i}$, o canal ruidoso que substitui a operaç\~{a}o ideal $U_{ideal}$ \cite{Mitiq2025_PEC, IBM2025_PEC}. Em seguida, cada porta ideal \'{e} decomposta como
\begin{equation*}
    U_{ideal} = \sum_i ~\eta_i ~U_{ruidoso, i}~,   
\end{equation*}
%
onde cada $U_{ruidoso, i}$  \'{e} uma implementaç\~{a}o ruidosa realiz\'{a}vel no \textit{hardware}, e $\eta_i$ s\~{a}o os coeficientes da distribuiç\~{a}o de quasi-probabilidade associada.

Para estimar o valor esperado de um observ\'{a}vel $O$, o PEC executa um conjunto de circuitos ruidosos, amostrados de acordo com a distribuiç\~{a}o de probabilidade $P(i) =\frac{|\eta_i|}{\gamma}$, sendo $\gamma = \sum_i |\eta_i|$ o fator de sobrecusto, e computa uma m\'{e}dia ponderada que incorpora o sinal $sign(\eta_i)$. Esse procedimento produz um estimador n\~{a}o enviesado, mas requer $O(\gamma^2)$ execuç\~{o}es do circuito, o que costuma crescer exponencialmente com a profundidade do circuito \cite{PhysRevLett2023_PEC}.

Essa sobrecarga de amostragem \'{e} rigorosamente limitada por resultados recentes que estabelecem limites universais para o custo de protocolos de mitigaç\~{a}o de erros, mostrando que qualquer m\'{e}todo gen\'{e}rico -- incluindo o PEC -- precisa de um n\'{u}mero de amostras proporcional a $\gamma^2$  para alcançar uma dada precis\~{a}o com alta probabilidade \cite{PhysRevResearch2021_PEC}.

Em s\'{i}ntese, o Cancelamento Probabil\'{i}stico de Erro oferece estimativas estatisticamente exatas dos valores esperados em circuitos qu\^{a}nticos ruidosos, mas demanda um custo de amostragem elevado -- governado pelo fator $\gamma$ -- e rigorosa caracterizaç\~{a}o do canal de ru\'{i}do. Por essa raz\~{a}o, ele \'{e} particularmente indicado para circuitos de baixa profundidade e cen\'{a}rios onde a precis\~{a}o n\~{a}o enviesada seja crucial para os resultados \cite{PRXQuantum2024_PEC}.
