\chapter{FUNDAMENTAÇ\~{a}O TEÓRICA}
\label{chap:fundamentacao}

A computaç\~{a}o qu\^{a}ntica vem ganhando destaque por sua capacidade de solucionar problemas considerados intrat\'{a}veis para sistemas cl\'{a}ssicos. Entre os algoritmos qu\^{a}nticos, o Algoritmo de Grover se destaca por oferecer uma melhoria quadr\'{a}tica na busca em bases de dados n\~{a}o estruturadas. Entretanto, a presença de ruídos nas QPUs – oriundos de fontes como decoer\^{e}ncia, interaç\~{a}o com o meio, imperfeições nas operações qu\^{a}nticas, dentre outras – impõe desafios que requerem a implementaç\~{a}o de estrat\'{e}gias que tornem os erros menos impactantes no resultado final. Este referencial teórico visa fundamentar os conceitos necess\'{a}rios para a compreens\~{a}o tanto do funcionamento e posterior implementaç\~{a}o do Algoritmo de Grover quanto dos m\'{e}todos de supress\~{a}o e mitigaç\~{a}o de ruídos que ser\~{a}o aplicados.

Na computaç\~{a}o qu\^{a}ntica, os \textit{quantum bits}, ou bits qu\^{a}nticos – chamados de \textit{qubits} – s\~{a}o a unidade fundamental de informaç\~{a}o. Diferente dos bits cl\'{a}ssicos, que assumem apenas os valores $0$ ou $1$, os qubits podem assumir estados de superposiç\~{a}o, que podemos entender como uma condiç\~{a}o em que o qubit “pode tamb\'{e}m assumir os dois valores simultaneamente. Nessa situaç\~{a}o, diz-se que  um  qubit  est\'{a}  em  superposiç\~{a}o  de  estados,  ou  coer\^{e}ncia” \cite{Cuzziol2023_Superposicao}; al\'{e}m disso, o computador qu\^{a}ntico \'{e} capaz de realizar o processamento paralelo das informações contidas nos qubits, denominado de paralelismo qu\^{a}ntico – quer dizer, o CQ consegue atuar em todos os qubits de forma síncrona, logo, \'{e} possível processar toda a informaç\~{a}o simultaneamente. Um outro conceito extremamente importante quando se fala n\~{a}o apenas de computaç\~{a}o qu\^{a}ntica especificamente, mas presente no cerne da mec\^{a}nica qu\^{a}ntica, \'{e} o que chamamos de emaranhamento qu\^{a}ntico, que \'{e} uma “consequ\^{e}ncia direta da condiç\~{a}o de superposiç\~{a}o” \cite{Rigolin2008_Emaranhamento}, e, em palavras simples, pode ser entendido como uma forte correlaç\~{a}o entre diferentes partículas, de modo que o estado de uma n\~{a}o pode ser descrito de forma desvinculada ao estado da outra, independentemente da dist\^{a}ncia que as separam, devido ao princípio da n\~{a}o localidade, que Einstein chama de “aç\~{a}o fantasmagórica à dist\^{a}ncia”. Ainda segundo Rigolin \citeyear{Rigolin2008_Emaranhamento}, “os estados emaranhados podem ainda serem usados para se realizar eficientemente tarefas impossíveis de serem executadas por meio de recursos cl\'{a}ssicos [...], como o teletransporte qu\^{a}ntico”.

Os \textit{chips} qu\^{a}nticos da IBM (QPUs) operam utilizando qubits supercondutores, que s\~{a}o projetados para reduzir a sensibilidade ao ruído de carga e aumentar a estabilidade dos estados qu\^{a}nticos. Para manter a supercondutividade, esses qubits operam a temperaturas extremamente baixas, próximas do zero absoluto. Esses qubits s\~{a}o manipulados pelas portas lógicas qu\^{a}nticas, isto \'{e}, o estado de qubit \'{e} modificado pela aplicaç\~{a}o de pulsos eletromagn\'{e}ticos de micro-ondas que induzem transições nos níveis de energia dos mesmos \cite{EITCA2024_CQ}
Dentre as portas lógicas qu\^{a}nticas existentes, podem ser citadas algumas como, por exemplo, as portas \emph{Hadamard} (\simboloinline{$H$}{Porta Lógica Quântica Hadamard}), \emph{Pauli-X} (\simboloinline{$X$}{Porta Lógica Quântica $X$}), \emph{Pauli-Z} (\simboloinline{$Z$}{Porta Lógica Quântica $Z$}), \emph{X-Controlada} (\simboloinline{$C_x,~CNOT$}{Porta Lógica Quântica $C_X$ ou $CNOT$}), \emph{Z-Controlada} (\simboloinline{$C_Z$}{Porta Lógica Quântica $C_Z$}) e a porta  \emph{Toffoli} (\emph{X-Multi-Controlada} de tr\^{e}s qubits (\simboloinline{$MCX$}{Porta Lógica Quântica $MCX$}), que s\~{a}o portas lógicas qu\^{a}nticas muito conhecidas, e disponíveis no \emph{Qiskit}, e quase todas ser\~{a}o abordadas no decorrer deste documento, visto que ser\~{a}o necess\'{a}rias para a construç\~{a}o do circuito qu\^{a}ntico (mais detalhes sobre construç\~{a}o e operaç\~{a}o de cada uma ser\~{a}o dados no Cap\'{i}tulo~\ref{chap:procedimentos}). Essas portas lógicas operam de forma a explorar as peculiaridades da mec\^{a}nica qu\^{a}ntica para efetuar c\'{a}lculos complexos \cite{Nielsen_Chuang2010_Livro}.

O Algoritmo de Grover, foco deste objeto, foi proposto por Grover \citeyear{grover1996} e tem como objetivo acelerar a busca em bases de dados n\~{a}o ordenadas. Seu funcionamento pode ser resumido em tr\^{e}s etapas principais: inicializaç\~{a}o, em que h\'{a} a criaç\~{a}o do Espaço de Pesquisa, que nada mais \'{e} que a superposiç\~{a}o uniforme de todos os estados possíveis; aplicaç\~{a}o do or\'{a}culo, uma operaç\~{a}o que marca (adicionando uma fase negativa) o(s) estado(s) que correspondem à soluç\~{a}o do problema; e, por fim, aplicaç\~{a}o do Operador de Difus\~{a}o ou de Amplificaç\~{a}o, que amplifica a probabilidade do estado marcado, tornando-o mais prov\'{a}vel de ser medido \cite{qiskit_GroverNotebook}. A efici\^{e}ncia do algoritmo de Grover se evidencia na sua capacidade de reduzir o número de buscas necess\'{a}rias em comparaç\~{a}o com os m\'{e}todos cl\'{a}ssicos, o que o torna uma ferramenta promissora em diversas aplicações, como a quebra de sistemas criptogr\'{a}ficos e otimizaç\~{a}o de buscas \cite{grover1996}.

Apesar do potencial dos algoritmos qu\^{a}nticos, os computadores qu\^{a}nticos atuais sofrem com a presença de ruído – decorrente de decoer\^{e}ncia dos qubits, imperfeições nas portas lógicas, interaç\~{a}o com o meio e erros de leitura. Esses fatores podem degradar significativamente a fidelidade dos resultados dos algoritmos, e uma fidelidade alta \'{e} crucial para garantir que os estados qu\^{a}nticos sejam preservados com alta precis\~{a}o durante as operações \cite{jozsa1994_Fidelidade}. Tomando por base esta asserç\~{a}o, fica evidente a necessidade e a import\^{a}ncia da utilizaç\~{a}o de m\'{e}todos que possam restringir a influ\^{e}ncia do ruído qu\^{a}ntico, de modo a garantir fidelidades maiores nos estados finais após as operações, gerando, por conseguinte, melhores e mais confi\'{a}veis resultados. 

O \emph{Qiskit SDK} possui uma gama de ferramentas para supress\~{a}o e mitigaç\~{a}o de ruído qu\^{a}ntico, e \'{e} intuito deste trabalho aplicar algumas delas ao circuito qu\^{a}ntico e analisar suas efetividades, emph{i. e.}, a capacidade de cada m\'{e}todo de melhorar o resultado final. S\~{a}o eles: Otimizaç\~{a}o do circuito compilado, Desacoplamento Din\^{a}mico (\simboloinline{DD}{\textit{Dynamical Decoupling}}), Compilaç\~{a}o Aleatória (\textit{Pauli Twirling}),  Extrapolaç\~{a}o de Erro Zero (\simboloinline{ZNE}{\textit{Zero-Noise Extrapolation}}), Extinç\~{a}o de Erro de Leitura Giratória (\simboloinline{TREX}{\textit{Twirled Readout Error eXtinction}}), Amplificaç\~{a}o de Erro Probabilístico (\simboloinline{PEA}{\textit{Probabilistic Error Amplification}}), Cancelamento de Erro Probabilístico (\simboloinline{PEC}{\textit{Probabilistic Error Cancellation}}).

\input{Secoes/SupressaoMitigacao}
